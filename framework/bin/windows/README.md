Delite scripts
==============

This set of scripts is designed to simplify playing with Delite. The bundle consists of three scripts per each family of operating systems: delitecfg/delitecfg.bat, delitec/delitec, and delite/delite.bat. There are also several auxiliary files, though we won't talk about them here.

Scripts require: sh interpreter when on Unix (not bash, since shell scripts in this package are really simple), batch interpreter when on Windows, java 1.6 or higher at system's PATH, and any scala interpreter at system's PATH to run the main portion of the scripts (we've tested the scripts with 2.8.1 and 2.9.0.1 - both worked finely). Scripts also rely on sbt (to inspect project metadata), though sbt is bundled along with the scripts, i.e. this dependency produces no additional requirements.

Scripts work correctly even if input filenames contain whitespaces. However they will fail if the path to Delite's home directory contains whitespaces (on Linux the runtime has a problem compiling code generated during staging, on Windows virtualized scala interpreter has troubles with understanding quoted -Ddelite.home.dir parameter - we'll address that eventually).

How to use
==========

Scripts assume that you have already built both LMS and Delite (i.e. successfully run "sbt publish-local" for the prior and "sbt compile" for the latter). If you haven't done that already, use instructions from <a href="http://stanford-ppl.github.com/Delite/getting_started.html">"Getting started"</a> at Delite's homepage.

All Delite applications have three phases: compiling (Scala), staging (DSL compilation), and executing (runtime). The first step, running the scala compiler, checks your application for syntactic and type correctness. Staging is where the main compilation happens: the DSL builds an IR of the program, optimizes it, and generates an execution graph along with code for multiple targets (e.g. Scala and CUDA). Finally, the Delite runtime reads in the execution graph and generated kernels and executes the application.

1) delitecfg/delitecfg.bat. These scripts initialize the environment for other Delite scripts. They ask you for the location of home directory of Delite and infer everything else on their own. Generated configuration file is saved to your home directory (~/.delitecfg on Unix, %USERPROFILE%\\.delitecfg.bat on Windows). The invocation looks as follows: <i>delitecfg &lt;path to Delite's home directory&gt;</i>. 

2) delitec/delitec.bat. (First and second phases, combined). During the first phase, the app gets compiled with scala-virtualized using settings generated by delitecfg. During the second phase, the compiled app gets staged with scala-virtualized using Delite Framework. The invocation looks as follows: <i>delitec [&lt;compiler options&gt;] [&lt;scala options&gt;] [&lt;framework configuration options&gt;] -Xrunner:&lt;name of the runner class&gt; &lt;paths to Scala files that constitute the app&gt;</i>. You can find more information about compiler options at <a href="http://www.scala-lang.org/docu/files/tools/scalac.html">scalac man page</a>.  You can find more information about scala options at <a href="http://www.scala-lang.org/docu/files/tools/scala.html">scala man page</a>. You can also customize <a href="https://github.com/TiarkRompf/virtualization-lms-core/blob/delite-develop/src/internal/Config.scala">the configuration of LMS Framework</a> and <a href="https://github.com/stanford-ppl/Delite/blob/develop/framework/src/ppl/delite/framework/Config.scala">the configuration of Delite Framework</a>. To do that, provide command-line arguments in -D&lt;property&gt;=&lt;value&gt; format. For example, to dump the IR of the code being staged, run: delitec -Dlms.verbosity=2 -Xrunner:&lt;name of the runner class&gt; &lt;paths to Scala files that constitute the app&gt;.

3) delite/delite.bat. (Third phase) These scripts invoke Delite runtime with user-provided DEG file and optional parameters. The invocation looks as follows: <i>delite [&lt;java options&gt;] [&lt;runtime configuration options&gt;] &lt;path to DEG file&gt; [&lt;application options&gt;]</i>. You can find more information about java options at <a href="http://download.oracle.com/javase/6/docs/technotes/tools/solaris/java.html">java man page</a>. You can also customize <a href="https://github.com/stanford-ppl/Delite/blob/develop/runtime/src/ppl/delite/runtime/Config.scala">the configuration of Delite Runtime</a>. To do that, provide command-line arguments in -D&lt;property&gt;=&lt;value&gt; format. For example, to dump the sources generated during this phase, run: delite -Ddelite.debug.print.sources=true &lt;path to DEG file&gt;.

Shortcuts
=========

To simplify usage of the scripts, we've implemented certain shortcuts. In most cases, some of the scripts allow you to omit certain mandatory arguments. For example, if in your Delite application you've got only one class named *Runner, then you may leave out the <i>-Xrunner:YourRunner</i> part of delitec invocation. Similarly, if your current directory has only one *.deg file, you may invoke delite without specifying its name. Here's how it works in more detail:

1) delitecfg/delitecfg.bat. You can invoke these scripts with no arguments. In that case they try to infer the location of Delite on their own (by peeking into the configuration file in your home directory) and, upon failure, switch to interactive mode. This feature is useful when you need to rebuild the configuration after updating delite.properties - delitecfg will reuse already configured location of Delite's home directory and will recalculate remaining configuration entries.

2) delitec/delitec.bat. If there's a single *Runner.class file in the compiler output directory and its subdirectories, you may omit the corresponding command-line argument and it will be inferred by delitec. Compiler output directory is assumed to be current directory or whatever is specified in -d &lt;directory&gt; option of scalac (for more information, take a look at <a href="http://www.scala-lang.org/docu/files/tools/scalac.html">scalac man page</a>). Of course, inference of the runner is performed after scala compilation phase, not before delitec is run.

3) delite/delite.bat. If the first argument of this script does not end with ".deg", delite attempts to infer the location of an input DEG file. For that, it scans current directory (though, not recurring to subdirectories) and picks a single file with the ".deg" extension. If your DEG file has unconventional extension, or if the first argument of your application ends in ".deg", you'll have to specify the location of the DEG file explicitly by using the -Xdeg:&lt;file&gt; option.

A hands-on example
==================

Along with the walkthrough, we present examples of console output for Ubuntu Linux. If you use another operating system, don't worry - we've made the scripts work equally well in all major OSes: Windows, Linux and Mac OS X. Your output might differ a bit, but Delite will work in the same way.

1) Go to any directory (you may create a new one, or use an existing one) and create a file called HelloWorld.scala with the following content:
<pre><code lang="scala">import ppl.dsl.optiml._

object HelloWorldRunner extends OptiMLApplicationRunner with HelloWorld 

trait HelloWorld extends OptiMLApplication { 
  def main() = println("hello world")
}
</code></pre>

2) Run <i>delitecfg &lt;path to Delite's home directory&gt;</i>. Provide the directory that you've cloned Delite sources into (the one with delite.properties). You may also run <i>delitecfg</i> without arguments and it will ask your for the directory in interactive mode. Here's an example of output:
<pre><code>xeno_by@xeno-main:~/Projects/Delite/HelloWorld$ delitecfg
Detecting the location of Delite...
Delite's home directory: /home/xeno_by/Projects/Delite/Delite/

Detecting the location of scala virtualized...
Scala virtualized home: /home/xeno_by/Projects/Delite/scala-virtualized/build/pack

Detecting the location of scala vanilla...
Scala vanilla home: /home/xeno_by/Projects/Delite/Delite/runtime/project/boot/scala-2.8.1

Detecting the location of LMS...
LMS's main compile path: /home/xeno_by/Projects/Delite/Delite/framework/lib_managed/scala_2.9.x-virtualized-SNAPSHOT/compile/virtualization-lms-core_2.9.x-virtualized-SNAPSHOT-0.1.jar

Detecting the location of Framework...
Framework's main compile path: /home/xeno_by/Projects/Delite/Delite/framework/target/scala_2.9.x-virtualized-SNAPSHOT/classes

Detecting the location of OptiML...
OptiML's main compile path: /home/xeno_by/Projects/Delite/Delite/dsls/optiml/target/scala_2.9.x-virtualized-SNAPSHOT/classes

Detecting the location of Runtime...
Runtime's main compile path: /home/xeno_by/Projects/Delite/Delite/runtime/target/scala_2.8.1/classes
</code></pre>

3) Run <i>delitec -Xrunner:HelloWorldRunner HelloWorld.scala</i>. This will perform initial compilation of HelloWorld.scala and prepare the test application for OptiML staging. After the compilation, HelloWorldRunner will be invoked to launch staging that expands virtualized code written in OptiML DSL into a number of scala source files (for more information, peek into the "generated" directory next to HelloWorld.scala). Staging will also produce a DEG file ("out.deg" by default) that contains an execution graph of the expanded program. Note that you may omit the -Xrunner option, since there's a single runner in our application - that would look as follows: <i>delitec HelloWorld.scala</i>. Here's an example of output:
<pre><code>xeno_by@xeno-main:~/Projects/Delite/HelloWorld$ delitec -Xrunner:HelloWorldRunner HelloWorld.scala
(Phase one) Scala compilation...
Successfully compiled

(Phase two) DSL compilation...
Delite Application Being Staged:[HelloWorldRunner$]
******Generating the program******
Successfully compiled
</code></pre>

4) Finally, run <i>delite out.deg</i>. This command fires up a JVM to actually execute staged code. You may also invoke <i>delite</i> without any arguments, granted there's a single DEG file in your current directory. Here's an example of output:
<pre><code>xeno_by@xeno-main:~/Projects/Delite/HelloWorld$ delite out.deg
Delite Runtime executing with the following arguments:
out.deg
Delite Runtime executing with 1 CPU thread(s) and 0 GPU(s)
Beginning Execution Run 1
hello world
[METRICS]: Latest time for component all: 0.001000s
</code></pre>
